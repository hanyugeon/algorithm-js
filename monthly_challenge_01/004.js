// 쿼드압축 후 개수 세기

/*
# 문제 설명
0과 1로 이루어진 2n x 2n 크기의 2차원 정수 배열 arr이 있습니다.
당신은 이 arr을 쿼드 트리와 같은 방식으로 압축하고자 합니다.
구체적인 방식은 다음과 같습니다.

당신이 압축하고자 하는 특정 영역을 S라고 정의합니다.
만약 S 내부에 있는 모든 수가 같은 값이라면, S를 해당 수 하나로 압축시킵니다.
그렇지 않다면, S를 정확히 4개의 균일한 정사각형 영역(입출력 예를 참고해주시기 바랍니다.)으로 쪼갠 뒤, 
각 정사각형 영역에 대해 같은 방식의 압축을 시도합니다.
arr이 매개변수로 주어집니다.
위와 같은 방식으로 arr을 압축했을 때, 
배열에 최종적으로 남는 0의 개수와 1의 개수를 배열에 담아서 return 하도록 solution 함수를 완성해주세요.

# 제한사항
arr의 행의 개수는 1 이상 1024 이하이며, 2의 거듭 제곱수 형태를 하고 있습니다.
즉, arr의 행의 개수는 1, 2, 4, 8, ..., 1024 중 하나입니다.
arr의 각 행의 길이는 arr의 행의 개수와 같습니다.
즉, arr은 정사각형 배열입니다.
arr의 각 행에 있는 모든 값은 0 또는 1 입니다.
*/

// 나의 풀이

/*
  00. 행의 갯수 찾기 (지수 n 구하기)
  01. 2**m개씩 묶는 함수(bunch) 구하기
    ex 1) n = 8:  {(0, 0), (0, 1), (1, 0), (1, 1)} / ... {(6, 6), (6, 7), (7, 6), (7, 7)}
    ex 2) n = 16: / ... {(14, 14), (14, 15), (15, 14), (15, 15)}
    위 예제는 bunch에 주어진 상수 m이 1 인 경우
  02. 함수(bunch)에 따라 2**m


*/

function solution(arr) {
  const answer = [0, 0];

  const func = (x, y, n) => {
    if (n === 1) return answer[arr[x][y]]++; // 크기가 1이면 해당 숫자 갯수 올리고 끝냄.

    let flag = true;

    for (let i = x; i < x + n; i++) {
      for (let j = y; j < y + n; j++) {
        if (arr[x][y] !== arr[i][j]) {
          flag = false;
          break; // 1개라도 다른 원소가 나오면 반복문 멈춤
        }
      }
    }

    if (flag) return answer[arr[x][y]]++; // 다 똑같은 숫자라면 갯수 올리고 끝냄

    n /= 2; // 쿼드 축소

    // 중첩 함수 (이렇게도 반복이 가능하구나...)
    func(x, y, n);
    func(x + n, y, n);
    func(x, y + n, n);
    func(x + n, y + n, n);
  };

  func(0, 0, arr.length);

  return answer;
}
